# MIPS アセンブリプログラム
# 機能: $s0の32ビット値を8ビットずつ4つのバイトに分割し、
#       それらの値を昇順に並べ替えて$s1に出力する。
#
# レジスタ使用方法:
# $s0: 入力レジスタ (32ビット値)
# $s1: 出力レジスタ (ソート・結合後の32ビット値)
# $t0: バイト0 (最下位バイト)
# $t1: バイト1
# $t2: バイト2
# $t3: バイト3 (最上位バイト)
# $t4: ソート時の一時的な値の交換用

.data
# テスト用の入力値。この値を変更してプログラムをテストできます。
# 例: 0xDEADBEEF
input_value: .word 0xDDBBCCAA

.text
.globl main

main:
    # ----------------------------------------------------
    # 1. 入力値のロードと8ビットずつへの分割
    # ----------------------------------------------------
    lw $s0, input_value      # メモリから$s0に入力値をロード

    # $s0から8ビットずつ4つの値を抽出する
    # ビットマスク(andi)とシフト(srl)を利用
    andi $t0, $s0, 0xFF      # バイト0 (bits 7-0)
    
    srl  $t1, $s0, 8         # 8ビット右にシフト
    andi $t1, $t1, 0xFF      # バイト1 (bits 15-8)
    
    srl  $t2, $s0, 16        # 16ビット右にシフト
    andi $t2, $t2, 0xFF      # バイト2 (bits 23-16)
    
    srl  $t3, $s0, 24        # 24ビット右にシフト
    andi $t3, $t3, 0xFF      # バイト3 (bits 31-24)

    # ----------------------------------------------------
    # 2. 4つの8ビット値のソート (バブルソート)
    # ----------------------------------------------------
    # 4つの要素なので、最大3回の比較パスでソートが完了する。
    
    # --- パス 1 ---
    # if ($t0 < $t1) then swap($t0, $t1)
    ble $t0, $t1, swap_t0_t1
    next1:
    # if ($t1 < $t2) then swap($t1, $t2)
    ble $t1, $t2, swap_t1_t2
    next2:
    # if ($t2 < $t3) then swap($t2, $t3)
    ble $t2, $t3, swap_t2_t3
    next3:

    # --- パス 2 ---
    # if ($t0 < $t1) then swap($t0, $t1)
    ble $t0, $t1, swap_t0_t1_p2
    next4:
    # if ($t1 < $t2) then swap($t1, $t2)
    ble $t1, $t2, swap_t1_t2_p2
    next5:

    # --- パス 3 ---
    # if ($t0 < $t1) then swap($t0, $t1)
    ble $t0, $t1, swap_t0_t1_p3
    next6:

    j combine                # ソートが完了したので結合処理へ

# --- ソート用のサブルーチン的なコードブロック ---
swap_t0_t1:
    move $t4, $t0; move $t0, $t1; move $t1, $t4; j next1
swap_t1_t2:
    move $t4, $t1; move $t1, $t2; move $t2, $t4; j next2
swap_t2_t3:
    move $t4, $t2; move $t2, $t3; move $t3, $t4; j next3
swap_t0_t1_p2:
    move $t4, $t0; move $t0, $t1; move $t1, $t4; j next4
swap_t1_t2_p2:
    move $t4, $t1; move $t1, $t2; move $t2, $t4; j next5
swap_t0_t1_p3:
    move $t4, $t0; move $t0, $t1; move $t1, $t4; j next6

    # ----------------------------------------------------
    # 3. ソートされた4つの値を1つの32ビット値に結合
    # ----------------------------------------------------
combine:
    # 昇順にソートされた$t0, $t1, $t2, $t3を$s1に結合する
    # $t0が最小値、$t3が最大値となっている。
    # 結果: $s1 = [最大値 | 3番目 | 2番目 | 最小値]
    #         $s1 = ($t3 << 24) | ($t2 << 16) | ($t1 << 8) | $t0
    
    move $s1, $t0            # $s1に最小値($t0)をセット

    sll  $t1, $t1, 8         # $t1を8ビット左シフト
    or   $s1, $s1, $t1       # $s1に$t1を結合

    sll  $t2, $t2, 16        # $t2を16ビット左シフト
    or   $s1, $s1, $t2       # $s1に$t2を結合

    sll  $t3, $t3, 24        # $t3を24ビット左シフト
    or   $s1, $s1, $t3       # $s1に$t3を結合 (これで完成)

    # ----------------------------------------------------
    # 4. プログラムの終了
    # ----------------------------------------------------
    li $v0, 10               # 終了コードを$v0にセット
    syscall                  # システムコールでプログラムを終了