.text
main:
  # s0に上限値xを設定 (簡単のため100をハードコーディング)
  li $s0, 100
  # 最初の素数として2をs3に設定
  li $s3, 2
  # 素数を格納するメモリの基準アドレスを設定
  li $t0, 0x1000A000
  # 見つかった双子素数のペアの個数を0で初期化
  li $s1, 0
  # 現在調べている奇数を3で初期化
  li $s2, 3

loop:
  # もし、現在調べている数($s2)が上限値($s0)を超えたら終了
  bgt  $s2, $s0, end

  # 割る数を3で初期化
  li   $t1, 3

is_prime:
  # $s2が素数かどうかを判定する
  # 割る数($t1)が調べている数($s2)以上になったら、素数とみなしhutagoへ
  bge  $t1, $s2, hutago
  # $s2を$t1で割った余りを$t2に格納
  rem  $t2, $s2, $t1
  # 余りが0なら素数ではないので、次の奇数のチェック(skip)へ
  beq  $t2, $zero, skip
  # 割る数を次の奇数へ (t1 = t1 + 2)
  addi $t1, $t1, 2
  # is_primeの判定ループに戻る
  j    is_prime

hutago:
  # $s2が、$s3(前の素数)の+2かどうかで双子素数かを判定する
  addi $t3, $s3, 2
  # $s3 + 2 == $s2 なら双子素数なので、storeへ
  beq  $t3, $s2, store
  # 双子素数でない場合、現在の素数($s2)を「次の前の素数」として$s3に保存
  move $s3, $s2
  # 次の奇数のチェック(skip)へ
  j    skip

store:
  # 双子素数の小さい方($s3)をメモリに格納
  sw   $s3, 0($t0)
  # 格納先アドレスを4バイト(1ワード)進める
  addi $t0, $t0, 4
  # ペアの個数を1増やす
  addi $s1, $s1, 1
  # 現在の素数($s2)を次の「前の素数」として$s3に保存
  move $s3, $s2

skip:
  # 次に調べる数を奇数なので2増やす
  addi $s2, $s2, 2
  # メインループの先頭に戻る
  j    loop

end:
  # 呼び出し元に戻る
  jr   $ra